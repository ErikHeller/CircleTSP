package CircleTSP.algo.path;

import CircleTSP.algo.cluster.PCA;
import CircleTSP.entities.Point;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.RealVector;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * This class provides an algorithm that calculates a hamiltonian path from points in a euclidean vector space.
 * It uses a given vector, projects all points onto this vector and sorts them in ascending order resulting in a path
 * that follows along this vector.
 * If no such vector is given, it will be generated by performing a principal component analysis (PCA) on the point set
 * and extracting the first principal component which will be used to find the path.
 *
 * Created by Erik Heller on 18.10.2019.
 */
public class LinearPath {


    /**
     * Calculate a path along the first principal component of the given points.
     * @param points Collection of points in a euclidean vector space.
     * @return Path along the first principal component of the given points that contains all points of the collection.
     */
    public static List<Point> findPath(Collection<Point> points) {
        PCA pca = new PCA(points);
        RealVector pc = pca.getEigenvector(0);
        return findPath(points, pc);
    }

    /**
     * Calculate a path along a vector pc.
     * @param points Collection of points in a euclidean vector space.
     * @param pc A vector (preferably a principal component of the point collection) on which all points shall
     *           be projected.
     * @return Path along the vector pc that contains all points of the collection.
     */
    public static List<Point> findPath(Collection<Point> points, RealVector pc) {
        List<Point> path = new ArrayList<>();
        SortedMap<Double, Point> projectionMap = new TreeMap<>();

        for (Point p : points) {
            RealVector v = new ArrayRealVector(p.getCoordinates());
            double projection = PCA.getProjection(v, pc);
            projectionMap.put(projection, p);
        }

        // Ordering is preserved in SortedMap.keySet()
        for (Double key : projectionMap.keySet()) {
            path.add(projectionMap.get(key));
        }

        return path;
    }
}
